[
  {
    "id": 1,
    "category": "functional",
    "priority": "high",
    "complexity": "S",
    "description": "Fix manifest min_engine_version in both BP and RP manifests. Currently set to [1, 26, 0] which does not exist \u2014 no Bedrock client can load the add-on. Change to [1, 21, 50] (the minimum version supporting @minecraft/server@2.5.0) in both MegaKnights_BP/manifest.json and MegaKnights_RP/manifest.json. Update CLAUDE.md if it references the wrong version.",
    "target_files": [
      "MegaKnights_BP/manifest.json",
      "MegaKnights_RP/manifest.json"
    ],
    "test_file": null,
    "related_to": [],
    "verification": [
      {
        "type": "source_contains",
        "file": "MegaKnights_BP/manifest.json",
        "pattern": "1, 21, 50"
      },
      {
        "type": "source_contains",
        "file": "MegaKnights_RP/manifest.json",
        "pattern": "1, 21, 50"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 2,
    "category": "functional",
    "priority": "high",
    "complexity": "S",
    "description": "Add endless mode defeat feedback. When all players die during an endless mini-siege, endSiege(false) is called but the endless branch has no player-facing message (comment: 'no defeat handling'). Add a message like '\u00a7c\u2694 Your defenses fell... but legends never truly die. The endless siege pauses until the next cycle.' so players understand what happened. Add new string constants to Strings.ts.",
    "target_files": [
      "src/data/Strings.ts",
      "src/systems/SiegeSystem.ts"
    ],
    "test_file": null,
    "related_to": [
      3,
      4
    ],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/data/Strings.ts",
        "pattern": "ENDLESS_DEFEAT"
      },
      {
        "type": "source_contains",
        "file": "src/systems/SiegeSystem.ts",
        "pattern": "ENDLESS_DEFEAT"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 3,
    "category": "functional",
    "priority": "high",
    "complexity": "M",
    "description": "Extend camp system to support endless mode (days > 100). Currently EnemyCampSystem.onDayChanged() returns early for day >= 100 and getCampTierForDay() returns undefined for days > 99. In endless mode, camps should continue spawning using the highest tier (Elite Outpost) for all days >= 85. Modify CampDefinitions.getCampTierForDay to handle days >= 100 by returning the last tier, and update EnemyCampSystem.onDayChanged to allow camps in endless mode.",
    "target_files": [
      "src/data/CampDefinitions.ts",
      "src/systems/EnemyCampSystem.ts"
    ],
    "test_file": null,
    "related_to": [
      2,
      4,
      9
    ],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/data/CampDefinitions.ts",
        "pattern": "getCampTierForDay"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/camp-system.test.ts"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 4,
    "category": "functional",
    "priority": "medium",
    "complexity": "M",
    "description": "Fix HUD display for endless mode. The HUD string shows 'Day X/100' which looks wrong when day > 100 in endless mode. When in endless mode and day > 100, the HUD should show 'Day X \u00a77(Endless)' instead of 'Day X/100'. Requires either a new HUD_ACTION_BAR_ENDLESS string in Strings.ts or modifying the existing HUD logic to detect endless mode. The progress bar should show full (all filled) in endless mode.",
    "target_files": [
      "src/data/Strings.ts",
      "src/systems/DayCounterSystem.ts"
    ],
    "test_file": null,
    "related_to": [
      16
    ],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/data/Strings.ts",
        "pattern": "HUD_ACTION_BAR_ENDLESS"
      },
      {
        "type": "source_contains",
        "file": "src/systems/DayCounterSystem.ts",
        "pattern": "HUD_ACTION_BAR_ENDLESS"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 5,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add unit tests for castle build command generation. CastleSystem uses fallback fill/setblock command arrays when .mcstructure files aren't present. These command arrays (buildSmallTower, buildGatehouse, buildGreatHall) are generated from pure logic and can be tested by reading the source as text and verifying the command patterns. Test that: commands reference valid block types, fill coordinates form valid cuboids, structure dimensions match CastleBlueprints definitions.",
    "target_files": [
      "src/systems/CastleSystem.ts",
      "src/data/CastleBlueprints.ts"
    ],
    "test_file": "src/__tests__/castle-commands.test.ts",
    "related_to": [],
    "verification": [
      {
        "type": "test_file_exists",
        "file": "src/__tests__/castle-commands.test.ts"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/castle-commands.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 6,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add unit tests for difficulty multiplier scaling on siege wave counts. Test that: (1) Normal difficulty (multiplier 1.0) uses base wave counts from WAVE_DEFINITIONS, (2) Hard difficulty (multiplier 1.5) correctly scales non-boss entity counts (boss always stays at count 1), (3) scaled counts are integers (Math.round or Math.ceil), (4) total per-wave entities with Hard multiplier still stay reasonable. Use source-as-text pattern since SiegeSystem imports @minecraft/server.",
    "target_files": [
      "src/systems/SiegeSystem.ts",
      "src/data/WaveDefinitions.ts"
    ],
    "test_file": "src/__tests__/difficulty-scaling.test.ts",
    "related_to": [
      7,
      12
    ],
    "verification": [
      {
        "type": "test_file_exists",
        "file": "src/__tests__/difficulty-scaling.test.ts"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/difficulty-scaling.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 7,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add unit tests for endless mode wave escalation logic. Verify: (1) ENDLESS_WAVES array has the expected number of wave sets, (2) wave sets escalate in total entity count, (3) the wave index selection formula ((day - 100) / 20) maps correctly to wave sets, (4) wave set index is clamped to array bounds for very high days, (5) entity IDs in endless waves are valid mk: namespace IDs that match defined entities.",
    "target_files": [
      "src/data/WaveDefinitions.ts"
    ],
    "test_file": "src/__tests__/endless-mode.test.ts",
    "related_to": [
      6,
      12
    ],
    "verification": [
      {
        "type": "test_file_exists",
        "file": "src/__tests__/endless-mode.test.ts"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/endless-mode.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 8,
    "category": "functional",
    "priority": "medium",
    "complexity": "M",
    "description": "Decouple QuestJournalSystem from direct world.getDynamicProperty() reads. QuestJournalSystem currently calls world.getDynamicProperty('mk:current_day') directly instead of going through DayCounterSystem.getCurrentDay(). This bypasses the cached value and adds an extra coupling to the property key string. Either pass DayCounterSystem to QuestJournalSystem constructor or expose a getCurrentDay() getter that QuestJournalSystem uses.",
    "target_files": [
      "src/systems/QuestJournalSystem.ts",
      "src/main.ts"
    ],
    "test_file": null,
    "related_to": [
      14
    ],
    "verification": [
      {
        "type": "source_not_contains",
        "file": "src/systems/QuestJournalSystem.ts",
        "pattern": "getDynamicProperty"
      },
      {
        "type": "source_contains",
        "file": "src/main.ts",
        "pattern": "QuestJournalSystem"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 9,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add tests for camp tier day range coverage and faction guard scaling. Verify: (1) CAMP_TIERS covers all days from CAMP_START_DAY (6) through 99 with no gaps, (2) each tier's guard count after faction weight scaling does not exceed MAX_CAMP_GUARDS, (3) FACTION_GUARD_WEIGHTS for all 3 factions produce integer guard counts when applied to each tier, (4) getCampTierForDay boundary values (day 6, 19, 20, 99) return correct tiers.",
    "target_files": [
      "src/data/CampDefinitions.ts"
    ],
    "test_file": "src/__tests__/camp-system.test.ts",
    "related_to": [
      3
    ],
    "verification": [
      {
        "type": "test_passes",
        "file": "src/__tests__/camp-system.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 10,
    "category": "functional",
    "priority": "medium",
    "complexity": "S",
    "description": "Standard Bearer naming consistency. MerchantSystem.onScrollUse() constructs the Standard Bearer name as '${safeName}\\'s Standard Bearer' instead of using generateAllyName() from AllyNames.ts like all other ally types. Update to use the shared naming utility so Standard Bearers get the same styled name format as other allies (or document clearly why the deviation is intentional).",
    "target_files": [
      "src/systems/MerchantSystem.ts"
    ],
    "test_file": null,
    "related_to": [],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/systems/MerchantSystem.ts",
        "pattern": "generateAllyName"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 11,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add tests for HUD composite key bit-packing correctness. The DayCounterSystem.updateHUD() method uses a 27-bit composite key packed as (day << 20) | (filled << 15) | (armySize << 9) | (armyCap << 3) | tier. Verify: (1) key is unique for different input combinations, (2) field widths accommodate max values (day=100+, filled=20, armySize=35, armyCap=35, tier=4), (3) no bit overflow between adjacent fields, (4) endless mode day values (100-300) produce valid keys.",
    "target_files": [
      "src/systems/DayCounterSystem.ts"
    ],
    "test_file": "src/__tests__/hud-bitpacking.test.ts",
    "related_to": [
      4
    ],
    "verification": [
      {
        "type": "test_file_exists",
        "file": "src/__tests__/hud-bitpacking.test.ts"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/hud-bitpacking.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 12,
    "category": "performance",
    "priority": "medium",
    "complexity": "M",
    "description": "Add performance budget tests for endless mode entity counts. The existing performance-budget.test.ts tests siege entity counts for the base game. Add tests that verify: (1) endless wave total spawns per wave never exceed MAX_ACTIVE_SIEGE_MOBS, (2) with Hard difficulty multiplier, endless wave counts are still bounded, (3) the mid-wave cap gating mechanism is referenced in SiegeSystem source. These ensure the Switch performance budget holds in endless mode too.",
    "target_files": [
      "src/systems/SiegeSystem.ts",
      "src/data/WaveDefinitions.ts"
    ],
    "test_file": "src/__tests__/performance-budget.test.ts",
    "related_to": [
      6,
      7
    ],
    "verification": [
      {
        "type": "test_passes",
        "file": "src/__tests__/performance-budget.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 13,
    "category": "content",
    "priority": "low",
    "complexity": "L",
    "description": "Add boss kill tracking to the bestiary. Currently the boss (mk:mk_boss_siege_lord) is excluded from bestiary tracking by the comment in CombatSystem. Add a BESTIARY entry for the Siege Lord with a single milestone (e.g., 1 kill = permanent Absorption I effect). This rewards players for beating the siege with a meaningful persistent buff.",
    "target_files": [
      "src/data/BestiaryDefinitions.ts",
      "src/systems/CombatSystem.ts"
    ],
    "test_file": "src/__tests__/bestiary.test.ts",
    "related_to": [],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/data/BestiaryDefinitions.ts",
        "pattern": "mk:mk_boss_siege_lord"
      },
      {
        "type": "source_contains",
        "file": "src/systems/CombatSystem.ts",
        "pattern": "bestiary"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/bestiary.test.ts"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 14,
    "category": "content",
    "priority": "low",
    "complexity": "M",
    "description": "Add Endless Mode section to Quest Journal. After the player wins the siege and enters endless mode, the Quest Journal should show a new section explaining endless mechanics: mini-sieges every 20 days, camp spawning continues, no more milestones, just survival. Add JOURNAL_ENDLESS_TITLE and JOURNAL_ENDLESS_BODY to Strings.ts and wire it into QuestJournalSystem to show conditionally when endless mode is active.",
    "target_files": [
      "src/data/Strings.ts",
      "src/systems/QuestJournalSystem.ts"
    ],
    "test_file": null,
    "related_to": [
      8
    ],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/data/Strings.ts",
        "pattern": "JOURNAL_ENDLESS_TITLE"
      },
      {
        "type": "source_contains",
        "file": "src/systems/QuestJournalSystem.ts",
        "pattern": "JOURNAL_ENDLESS"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 15,
    "category": "test",
    "priority": "low",
    "complexity": "M",
    "description": "Validate all recipe ingredients are obtainable at the expected game stage. Read all recipe JSON files and cross-reference ingredients against: (1) vanilla Minecraft items that are always available, (2) custom mk: items that are given at specific milestones/days, (3) camp reward drops. Ensure no recipe requires an item that the player cannot obtain by the time the recipe becomes relevant (e.g., a Day 35 blueprint recipe shouldn't require netherite which is a Day 85+ camp reward).",
    "target_files": [
      "src/data/ArmorTiers.ts",
      "src/data/CastleBlueprints.ts",
      "src/data/CampDefinitions.ts"
    ],
    "test_file": "src/__tests__/recipe-ingredients.test.ts",
    "related_to": [],
    "verification": [
      {
        "type": "test_passes",
        "file": "src/__tests__/recipe-ingredients.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 16,
    "category": "polish",
    "priority": "low",
    "complexity": "S",
    "description": "Add DAY_CHANGE string variant for endless mode. Currently DAY_CHANGE shows '=== Day X of 100 ===' for all days including endless mode. When day > 100, this should show '=== Day X (Endless) ===' or similar. Add a DAY_CHANGE_ENDLESS constant to Strings.ts and update DayCounterSystem.onDayChange to use it when in endless mode.",
    "target_files": [
      "src/data/Strings.ts",
      "src/systems/DayCounterSystem.ts"
    ],
    "test_file": null,
    "related_to": [
      4
    ],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/data/Strings.ts",
        "pattern": "DAY_CHANGE_ENDLESS"
      },
      {
        "type": "source_contains",
        "file": "src/systems/DayCounterSystem.ts",
        "pattern": "DAY_CHANGE_ENDLESS"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 17,
    "category": "test",
    "priority": "low",
    "complexity": "M",
    "description": "Add tests verifying all entity JSON files have required Bedrock fields. Check every .se.json (BP) and .ce.json (RP) file for: (1) valid format_version string, (2) minecraft:entity with description.identifier matching mk:mk_* pattern, (3) required component groups are present, (4) event handlers reference valid component groups, (5) no duplicate component group names. This catches content authoring errors before testing in-game.",
    "target_files": [
      "MegaKnights_BP/entities/",
      "MegaKnights_RP/entity/"
    ],
    "test_file": "src/__tests__/entity-validation.test.ts",
    "related_to": [],
    "verification": [
      {
        "type": "test_file_exists",
        "file": "src/__tests__/entity-validation.test.ts"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/entity-validation.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 18,
    "category": "test",
    "priority": "low",
    "complexity": "M",
    "description": "Add integration-style tests for main.ts system wiring completeness. Verify by reading main.ts source that: (1) all 11 systems are instantiated, (2) all death listeners are set up (army, siege, camp), (3) all event subscriptions cover itemUse for all expected item typeIds, (4) the difficulty multiplier is wired to siege, camp, and milestones, (5) the onVictory callback enables endless mode. Some of these may already exist in system-wiring.test.ts \u2014 extend if gaps found.",
    "target_files": [
      "src/main.ts"
    ],
    "test_file": "src/__tests__/system-wiring.test.ts",
    "related_to": [],
    "verification": [
      {
        "type": "test_passes",
        "file": "src/__tests__/system-wiring.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 19,
    "category": "functional",
    "priority": "high",
    "complexity": "S",
    "description": "Fix setDay() to support endless mode days > 100. DayCounterSystem.setDay() clamps to MAX_DAY=100 unconditionally (line 154), preventing debug testing of endless mode at higher days. When endless mode is active (cachedEndless=true), allow days beyond 100. Change the clamp to use a higher max (e.g., 999) when endless mode is active. Also update the sendMessage in main.ts mk:setday handler which clamps independently to 100.",
    "target_files": [
      "src/systems/DayCounterSystem.ts",
      "src/main.ts"
    ],
    "test_file": "src/__tests__/setday-endless.test.ts",
    "related_to": [
      29
    ],
    "verification": [
      {
        "type": "source_not_contains",
        "file": "src/systems/DayCounterSystem.ts",
        "pattern": "Math.min(DayCounterSystem.MAX_DAY, day)"
      },
      {
        "type": "source_contains",
        "file": "src/systems/DayCounterSystem.ts",
        "pattern": "cachedEndless"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 20,
    "category": "functional",
    "priority": "high",
    "complexity": "M",
    "description": "Add endless mode merchant spawning. MERCHANT_DAYS only contains [15, 30, 55, 75, 95], so the Wandering Merchant never appears in endless mode (day > 100). Add support for recurring merchant days in endless mode \u2014 e.g., every 25 days starting from day 125 (125, 150, 175, ...). Update MerchantSystem.onDayChanged() to check for endless-mode merchant days in addition to the static set. Consider making this a pure function so it's testable.",
    "target_files": [
      "src/systems/MerchantSystem.ts"
    ],
    "test_file": "src/__tests__/merchant.test.ts",
    "related_to": [
      30
    ],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/systems/MerchantSystem.ts",
        "pattern": "endless"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 21,
    "category": "functional",
    "priority": "high",
    "complexity": "M",
    "description": "Reset player properties on mk:reset. Currently mk:reset (main.ts) only calls dayCounter.reset() and difficulty.reset(), which clear world-level dynamic properties. Player-level properties are NOT cleared: mk:kills, mk:army_size, mk:current_tier, mk:army_bonus, mk:has_started, mk:tier_unlocked_*, and bestiary kills (mk:bestiary_kills_*). After reset, players keep their earned buffs, army bonuses, and tier progress. Add a resetAllPlayers() method that iterates all players and clears these properties.",
    "target_files": [
      "src/main.ts",
      "src/systems/DayCounterSystem.ts"
    ],
    "test_file": "src/__tests__/reset-completeness.test.ts",
    "related_to": [
      28
    ],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/main.ts",
        "pattern": "mk:army_size"
      },
      {
        "type": "source_contains",
        "file": "src/main.ts",
        "pattern": "mk:has_started"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 22,
    "category": "functional",
    "priority": "medium",
    "complexity": "S",
    "description": "Fix spawnEndlessWave missing playerMap refresh after entity cap pause. In SiegeSystem.spawnWave() (lines 373-381), after the `while (siegeMobCount >= MAX_ACTIVE_SIEGE_MOBS)` yield loop, the playerMap is refreshed to get fresh player references. In spawnEndlessWave() (lines 462-464), the same yield loop exists but WITHOUT the post-pause refresh. Players may have disconnected/reconnected during the pause, making stale references cause spawn failures. Copy the refresh pattern from spawnWave().",
    "target_files": [
      "src/systems/SiegeSystem.ts"
    ],
    "test_file": null,
    "related_to": [
      23
    ],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/systems/SiegeSystem.ts",
        "pattern": "Refresh player map after pause"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 23,
    "category": "performance",
    "priority": "medium",
    "complexity": "M",
    "description": "Refactor SiegeSystem to deduplicate spawn logic. spawnWave() and spawnEndlessWave() share ~90% identical code: building a spawn queue from player list with scaling, running a staggered system.runJob generator with playerMap management, mid-wave entity cap gating, and activeSpawnJobs tracking. Extract a shared private method like staggeredSpawn(spawnQueue, players) that both methods call. This eliminates the maintenance risk of one copy having a fix the other doesn't (like the missing playerMap refresh in task #22).",
    "target_files": [
      "src/systems/SiegeSystem.ts"
    ],
    "test_file": null,
    "related_to": [
      22
    ],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/systems/SiegeSystem.ts",
        "pattern": "staggeredSpawn"
      },
      {
        "type": "source_not_contains",
        "file": "src/systems/SiegeSystem.ts",
        "pattern": "spawnEndlessWave"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 24,
    "category": "functional",
    "priority": "medium",
    "complexity": "S",
    "description": "Fix debugSpawnAllies to use generateAllyName(). ArmySystem.debugSpawnAllies() (line 364-365) uses a hardcoded format `${safeName}'s Knight` instead of the shared generateAllyName() utility that all other ally spawning paths use. This means debug allies get different-style names than real recruits. Update to use generateAllyName('mk:mk_ally_knight') for consistency.",
    "target_files": [
      "src/systems/ArmySystem.ts"
    ],
    "test_file": null,
    "related_to": [],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/systems/ArmySystem.ts",
        "pattern": "generateAllyName"
      },
      {
        "type": "source_not_contains",
        "file": "src/systems/ArmySystem.ts",
        "pattern": "safeName}'s Knight"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 25,
    "category": "functional",
    "priority": "medium",
    "complexity": "S",
    "description": "Make QuestJournal recruit chance dynamic based on difficulty. JOURNAL_ARMY_BODY in Strings.ts hardcodes '30% chance to recruit them' but Hard difficulty uses 20% (RECRUIT_CHANCES in DifficultySystem). Pass DifficultySystem to QuestJournalSystem constructor and use the actual recruit chance in the army body text. Convert JOURNAL_ARMY_BODY from a constant to a function that takes the recruit percentage.",
    "target_files": [
      "src/data/Strings.ts",
      "src/systems/QuestJournalSystem.ts",
      "src/main.ts"
    ],
    "test_file": null,
    "related_to": [
      26
    ],
    "verification": [
      {
        "type": "source_contains",
        "file": "src/systems/QuestJournalSystem.ts",
        "pattern": "DifficultySystem"
      },
      {
        "type": "source_contains",
        "file": "src/data/Strings.ts",
        "pattern": "JOURNAL_ARMY_BODY"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 26,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add QuestJournalSystem tests. Using source-as-text pattern (read QuestJournalSystem.ts as text), verify: (1) all JOURNAL_* string constants from Strings.ts are referenced, (2) endless mode button is conditionally added (isEndlessMode check), (3) bestiary display iterates all BESTIARY entries, (4) TOC button count matches switch case count, (5) DayCounterSystem is used for getCurrentDay (not direct getDynamicProperty), (6) DifficultySystem reference exists for dynamic recruit chance.",
    "target_files": [
      "src/systems/QuestJournalSystem.ts",
      "src/data/Strings.ts"
    ],
    "test_file": "src/__tests__/quest-journal.test.ts",
    "related_to": [
      25
    ],
    "verification": [
      {
        "type": "test_file_exists",
        "file": "src/__tests__/quest-journal.test.ts"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/quest-journal.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 27,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add DifficultySystem tests. Using source-as-text pattern, verify: (1) DIFFICULTY_NORMAL=0 and DIFFICULTY_HARD=1 constants exist, (2) RECRUIT_CHANCES maps both difficulties to reasonable values (0.2-0.5 range), (3) ENEMY_MULTIPLIERS maps both difficulties (1.0 and 1.5), (4) reset() clears cached value and calls setDynamicProperty with undefined, (5) getDifficulty() reads from cache when available, (6) dynamic property key is 'mk:difficulty'. Import the exported constants directly since DifficultySystem imports @minecraft/server.",
    "target_files": [
      "src/systems/DifficultySystem.ts"
    ],
    "test_file": "src/__tests__/difficulty-system.test.ts",
    "related_to": [],
    "verification": [
      {
        "type": "test_file_exists",
        "file": "src/__tests__/difficulty-system.test.ts"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/difficulty-system.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 28,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add mk:reset completeness tests. Using source-as-text pattern on main.ts, verify that the mk:reset handler: (1) calls dayCounter.reset(), (2) calls difficulty.reset(), (3) clears ALL player-level dynamic properties (mk:kills, mk:army_size, mk:current_tier, mk:army_bonus, mk:has_started, mk:tier_unlocked_*, mk:bestiary_kills_*), (4) sends DEBUG_QUEST_RESET message. Cross-reference against all dynamic property keys used in the codebase to ensure none are missed.",
    "target_files": [
      "src/main.ts",
      "src/systems/DayCounterSystem.ts",
      "src/systems/BestiarySystem.ts"
    ],
    "test_file": "src/__tests__/reset-completeness.test.ts",
    "related_to": [
      21
    ],
    "verification": [
      {
        "type": "test_file_exists",
        "file": "src/__tests__/reset-completeness.test.ts"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/reset-completeness.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 29,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add setDay endless mode tests. Using source-as-text pattern on DayCounterSystem.ts, verify: (1) setDay() uses a higher clamp limit when endless mode is active (not always capped at 100), (2) milestones fire correctly for jumped days in setDay, (3) the staggered milestone execution via system.runJob is present, (4) endless mode day values (101-999) are not clamped to 100. Also test the main.ts mk:setday handler doesn't independently clamp to 100.",
    "target_files": [
      "src/systems/DayCounterSystem.ts",
      "src/main.ts"
    ],
    "test_file": "src/__tests__/setday-endless.test.ts",
    "related_to": [
      19
    ],
    "verification": [
      {
        "type": "test_file_exists",
        "file": "src/__tests__/setday-endless.test.ts"
      },
      {
        "type": "test_passes",
        "file": "src/__tests__/setday-endless.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 30,
    "category": "test",
    "priority": "low",
    "complexity": "M",
    "description": "Add merchant endless mode tests. Verify: (1) MerchantSystem.onDayChanged() or a new helper function recognizes endless-mode merchant days (day > 100, recurring pattern), (2) the static MERCHANT_DAYS set still works for normal play (days 15-95), (3) no merchant spawns on non-merchant endless days, (4) merchant spawns on the correct recurring endless-mode days. Use source-as-text pattern since MerchantSystem imports @minecraft/server.",
    "target_files": [
      "src/systems/MerchantSystem.ts"
    ],
    "test_file": "src/__tests__/merchant.test.ts",
    "related_to": [
      20
    ],
    "verification": [
      {
        "type": "test_passes",
        "file": "src/__tests__/merchant.test.ts"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 31,
    "category": "polish",
    "priority": "low",
    "complexity": "S",
    "description": "Fix HUD bitpacking comment to reflect actual bit usage. The comment on DayCounterSystem line 352 says 'Packs day(7), filled(5), armySize(6), armyCap(6), tier(3) = 27 bits' but in endless mode, day can exceed 127 (7-bit max), using 8-9 bits. The code works correctly (JS Numbers have 53-bit integer precision and fields don't overlap) but the comment is misleading. Update the comment to clarify that day uses variable width and total bits can exceed 27 in endless mode.",
    "target_files": [
      "src/systems/DayCounterSystem.ts"
    ],
    "test_file": null,
    "related_to": [],
    "verification": [
      {
        "type": "source_not_contains",
        "file": "src/systems/DayCounterSystem.ts",
        "pattern": "27 bits"
      },
      {
        "type": "source_contains",
        "file": "src/systems/DayCounterSystem.ts",
        "pattern": "53-bit"
      },
      {
        "type": "build_passes"
      },
      {
        "type": "all_tests_pass"
      }
    ],
    "passes": true
  },
  {
    "id": 32,
    "category": "functional",
    "priority": "high",
    "complexity": "S",
    "description": "Fix camp double-clear race condition. EnemyCampSystem has a race where both the death listener (line 93-94) and the safety recount tick() (line 126-127) can call campCleared() on the same camp. If the last guard dies and tick() runs before the camp entry is deleted from the Map iterator, rewards are dropped twice and the clear message is sent twice. Fix: add a `cleared` boolean to the CampState interface (default false), set it to true at the start of campCleared(), and check it before proceeding in both the death listener and tick() paths.",
    "target_files": [
      "src/systems/EnemyCampSystem.ts"
    ],
    "test_file": "src/__tests__/camp-cleared-guard.test.ts",
    "related_to": [39],
    "verification": [
      { "type": "source_contains", "file": "src/systems/EnemyCampSystem.ts", "pattern": "cleared" },
      { "type": "source_contains", "file": "src/systems/EnemyCampSystem.ts", "pattern": "camp.cleared" },
      { "type": "build_passes" },
      { "type": "all_tests_pass" }
    ],
    "passes": false
  },
  {
    "id": 33,
    "category": "functional",
    "priority": "high",
    "complexity": "M",
    "description": "Add siege mob cleanup on endSiege. When a siege ends (victory or defeat), SiegeSystem.endSiege() sets siegeActive=false but never removes surviving mk_siege_mob entities. These entities continue wandering and consuming the entity budget. In endless mode, where mini-sieges happen every 20 days, residual mobs accumulate rapidly. Fix: in endSiege(), after setting siegeActive=false, query all mk_siege_mob tagged entities and remove them via system.runJob (staggered, 2 per tick for Switch performance). Reset siegeMobCount to 0 after cleanup.",
    "target_files": [
      "src/systems/SiegeSystem.ts"
    ],
    "test_file": "src/__tests__/siege-cleanup.test.ts",
    "related_to": [40],
    "verification": [
      { "type": "source_contains", "file": "src/systems/SiegeSystem.ts", "pattern": "mk_siege_mob" },
      { "type": "source_contains", "file": "src/systems/SiegeSystem.ts", "pattern": "cleanupSiegeMobs" },
      { "type": "build_passes" },
      { "type": "all_tests_pass" }
    ],
    "passes": false
  },
  {
    "id": 34,
    "category": "functional",
    "priority": "medium",
    "complexity": "S",
    "description": "Extract duplicate TIER_NAMES constant to shared location. Both DayCounterSystem.ts (line 31) and QuestJournalSystem.ts (line 24) define the same hardcoded array ['Page', 'Squire', 'Knight', 'Champion', 'Mega Knight']. If tiers change, both files would need updating. Export TIER_NAMES from ArmorTiers.ts (which already defines ARMOR_TIERS with tier data) and import it in both system files, removing the local duplicates.",
    "target_files": [
      "src/data/ArmorTiers.ts",
      "src/systems/DayCounterSystem.ts",
      "src/systems/QuestJournalSystem.ts"
    ],
    "test_file": "src/__tests__/tier-names-shared.test.ts",
    "related_to": [41],
    "verification": [
      { "type": "source_contains", "file": "src/data/ArmorTiers.ts", "pattern": "TIER_NAMES" },
      { "type": "source_not_contains", "file": "src/systems/DayCounterSystem.ts", "pattern": "const TIER_NAMES = [" },
      { "type": "source_not_contains", "file": "src/systems/QuestJournalSystem.ts", "pattern": "const TIER_NAMES = [" },
      { "type": "build_passes" },
      { "type": "all_tests_pass" }
    ],
    "passes": false
  },
  {
    "id": 35,
    "category": "functional",
    "priority": "medium",
    "complexity": "S",
    "description": "Fix siege recount overworld dimension assumption. SiegeSystem tick() line 245 hardcodes world.getDimension('overworld') for the safety-net recount. If a player triggers mk:siege while in the Nether or End, all siege mobs spawn in that dimension but the recount always queries the overworld, missing them entirely. The siegeMobCount drifts to 0 from death events while the recount 'corrects' it to 0 too (no entities found in overworld), causing premature victory. Fix: store the dimension ID at siege start (startSiege/startEndlessSiege) and use it in the recount query.",
    "target_files": [
      "src/systems/SiegeSystem.ts"
    ],
    "test_file": null,
    "related_to": [],
    "verification": [
      { "type": "source_contains", "file": "src/systems/SiegeSystem.ts", "pattern": "siegeDimensionId" },
      { "type": "source_not_contains", "file": "src/systems/SiegeSystem.ts", "pattern": "getDimension(\"overworld\")" },
      { "type": "build_passes" },
      { "type": "all_tests_pass" }
    ],
    "passes": false
  },
  {
    "id": 36,
    "category": "performance",
    "priority": "low",
    "complexity": "S",
    "description": "Add BestiarySystem lookup cache. BestiarySystem.getEntryForType() (line 80-84) performs a linear scan through the BESTIARY array on every enemy kill. While only 5 entries, this is a hot path during combat with many enemies dying rapidly. Cache a Map<typeId, BestiaryEntry> built once in the constructor, and use it for O(1) lookups in getEntryForType().",
    "target_files": [
      "src/systems/BestiarySystem.ts"
    ],
    "test_file": null,
    "related_to": [],
    "verification": [
      { "type": "source_contains", "file": "src/systems/BestiarySystem.ts", "pattern": "entryByType" },
      { "type": "source_contains", "file": "src/systems/BestiarySystem.ts", "pattern": "new Map" },
      { "type": "build_passes" },
      { "type": "all_tests_pass" }
    ],
    "passes": false
  },
  {
    "id": 37,
    "category": "polish",
    "priority": "low",
    "complexity": "S",
    "description": "Extract endless wave escalation magic number. SiegeSystem.ts line 161 uses a hardcoded 40 in `Math.floor((day - 100) / 40)` for endless wave escalation without a named constant. Add `const ENDLESS_WAVE_ESCALATION_DAYS = 40` near the other constants at the top of SiegeSystem.ts and use it in the calculation. This improves readability and makes tuning easier.",
    "target_files": [
      "src/systems/SiegeSystem.ts"
    ],
    "test_file": null,
    "related_to": [],
    "verification": [
      { "type": "source_contains", "file": "src/systems/SiegeSystem.ts", "pattern": "ENDLESS_WAVE_ESCALATION_DAYS" },
      { "type": "build_passes" },
      { "type": "all_tests_pass" }
    ],
    "passes": false
  },
  {
    "id": 38,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add friendly fire protection tests. main.ts (lines 114-171) implements friendly fire heal-back, message throttling, and owner tag verification, but no dedicated test suite exists. Using source-as-text pattern on main.ts, verify: (1) entityHurt subscription exists with mk_army tag check, (2) owner tag verification via getOwnerTag, (3) heal-back uses health.setCurrentValue with clamped value, (4) throttle interval is 60 ticks between messages per player, (5) FRIENDLY_FIRE_BLOCKED string is imported and used, (6) system.run() defers heal-back mutation.",
    "target_files": [
      "src/main.ts"
    ],
    "test_file": "src/__tests__/friendly-fire.test.ts",
    "related_to": [],
    "verification": [
      { "type": "test_file_exists", "file": "src/__tests__/friendly-fire.test.ts" },
      { "type": "test_passes", "file": "src/__tests__/friendly-fire.test.ts" },
      { "type": "all_tests_pass" }
    ],
    "passes": false
  },
  {
    "id": 39,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add camp cleared idempotency tests. After task #32 adds the `cleared` flag to CampState, verify via source-as-text on EnemyCampSystem.ts: (1) CampState interface includes `cleared: boolean`, (2) campCleared() checks camp.cleared before proceeding, (3) campCleared() sets camp.cleared = true, (4) death listener path checks cleared before calling campCleared, (5) tick() recount path checks cleared before calling campCleared, (6) new camps initialize with cleared: false.",
    "target_files": [
      "src/systems/EnemyCampSystem.ts"
    ],
    "test_file": "src/__tests__/camp-cleared-guard.test.ts",
    "related_to": [32],
    "verification": [
      { "type": "test_file_exists", "file": "src/__tests__/camp-cleared-guard.test.ts" },
      { "type": "test_passes", "file": "src/__tests__/camp-cleared-guard.test.ts" },
      { "type": "all_tests_pass" }
    ],
    "passes": false
  },
  {
    "id": 40,
    "category": "test",
    "priority": "medium",
    "complexity": "M",
    "description": "Add siege mob cleanup tests. After task #33 adds cleanup logic to endSiege(), verify via source-as-text on SiegeSystem.ts: (1) endSiege() calls a cleanup method (cleanupSiegeMobs or inline), (2) cleanup queries entities with mk_siege_mob tag, (3) cleanup uses staggered removal (system.runJob or batched system.run), (4) siegeMobCount is reset to 0 after cleanup, (5) both victory and defeat paths trigger cleanup, (6) endless mode endSiege also triggers cleanup.",
    "target_files": [
      "src/systems/SiegeSystem.ts"
    ],
    "test_file": "src/__tests__/siege-cleanup.test.ts",
    "related_to": [33],
    "verification": [
      { "type": "test_file_exists", "file": "src/__tests__/siege-cleanup.test.ts" },
      { "type": "test_passes", "file": "src/__tests__/siege-cleanup.test.ts" },
      { "type": "all_tests_pass" }
    ],
    "passes": false
  },
  {
    "id": 41,
    "category": "test",
    "priority": "low",
    "complexity": "S",
    "description": "Add TIER_NAMES shared constant tests. After task #34 extracts TIER_NAMES to ArmorTiers.ts, verify: (1) ArmorTiers.ts exports TIER_NAMES, (2) TIER_NAMES has exactly 5 entries matching ARMOR_TIERS count, (3) TIER_NAMES entries match ARMOR_TIERS[i].name or expected values, (4) DayCounterSystem.ts imports TIER_NAMES from ArmorTiers (not local const), (5) QuestJournalSystem.ts imports TIER_NAMES from ArmorTiers (not local const).",
    "target_files": [
      "src/data/ArmorTiers.ts",
      "src/systems/DayCounterSystem.ts",
      "src/systems/QuestJournalSystem.ts"
    ],
    "test_file": "src/__tests__/tier-names-shared.test.ts",
    "related_to": [34],
    "verification": [
      { "type": "test_file_exists", "file": "src/__tests__/tier-names-shared.test.ts" },
      { "type": "test_passes", "file": "src/__tests__/tier-names-shared.test.ts" },
      { "type": "all_tests_pass" }
    ],
    "passes": false
  }
]
